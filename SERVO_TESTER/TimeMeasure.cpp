/////////////////////////////////////////////////////////////////////////////////
//
// ЛИЦЕНЗИЯ
//
// Данный код поставляется по лицензии ПНХ.
//
// 1. Вы можете свободно использовать или не использовать его в коммерческих, 
//    некоммерческих, и любых других, не запрещённых законом, целях.
//
// 2. Автор не несёт решительно никакой ответственности за любые положительные
//    или отрицательные результаты использования или неиспользования данного кода.
//
// 3. Если Вам таки хочется сделать автору предъяву, то … Вы знаете куда
//    Вам следует пройти, А если не знаете, то см. название лицензии.
//
// 4. Если данный код вдруг пригодился (как учебник или ещё как что) и Вам
//    почему-либо (ну, приболели, может) захотелось отблагодарить автора рублём,
//    то это всегда пожалуйста – WebMoney, кошелёк № R626206676373
//    (тут название лицензии не канает). 
//
#include  <arduino.h>
#include  "TimeMeasure.h"

//
//  ATmega328/P и ничего другого!
//
//  Измеряем время высокого уровня на пине 2 (aka PD2)
//  (чтобы измерять на пине 3 (PD3), нужно раскомментировать следующую строку)
//#define USE_INT_1
//
//  Испольует таймер №1, но если надо работать с тамером №2, нужно раскомментировать сл. строку
#define USE_TIMER_2
//
//  Измеряемый интервал - от 80 до 65534 тактов процессора
//  (при 20МГц это 4 - 3275 микросекунд, при 16МГц это 5 - 4095 микросекунд
//  Если высокий уровень держится 65535 тактов, то
//  считаем это ошибкой и выдаём результат ENDLESS_INTERVAL
//
//  Результат измерений - количество тактов процессора.
//  Чтобы получить время в микросекундах, нужно полученный результат
//  разделить на константу TICKS_PER_MICROSECOND
//  

#ifdef  USE_INT_1 // используем пин 3

  #define PIN_NUMBER  3
  #define PIN_MASK  (bit(PD3))
  #define INT_FLAG  INT1
  #define MODE_BIT  ISC10
  #define INT_VECT  INT1_vect

#else // используем пин 2

  #define PIN_NUMBER  2
  #define PIN_MASK  (bit(PD2))
  #define INT_FLAG  INT0
  #define MODE_BIT  ISC00
  #define INT_VECT  INT0_vect
  
#endif

//
//  Инициализация таймера-счётчика 
//  Состоит из начальной инициализации, которая выполняется один раз
//  и дополнительной инициализации, которая выполняется перед каждым 
//  измерением (stopTimerCounter)
//
#ifdef  USE_TIMER_2
  static volatile uint16_t ovfCounter = 0;

  static void stopTimerCounter(void) {
    TCCR2B = 0; //  остановим таймер
    TCNT2 = 0;  // считаем с 0
    ovfCounter = 0;
  }
  static void initTimerCounter(void) {
    stopTimerCounter();
    TCCR2A = 0;
    TCCR2B = 0;
    TIMSK2 = bit(TOIE2);  //  Разрешить прерывание по переполнению
  }
#else
  static void stopTimerCounter(void) {
    TCCR1B = 0; //  остановим таймер
    TCNT1 = 0;  // считаем с 0
  }
  static void initTimerCounter(void) {
    stopTimerCounter();
    TIMSK1 = bit(TOIE1);  //  Разрешить прерывание по переполнению
    TCCR1A = 0;
    TCCR1C = 0;
  }
#endif  //  USE_TIMER_2

//
//  Инициализация внешнего прерывания 0/1 на смену состояния
//
static void initInterrupt0(void) {
  EICRA = bit(MODE_BIT);  // на смену состояния
  EIMSK = bit(INT_FLAG);  // прерывание 0/1
}

//
//  Инициализация всего (нужно вызвать из setup)
//
void initTimeMeasuring(void) {
  pinMode(PIN_NUMBER, INPUT);
  initTimerCounter();
  initInterrupt0();
}

static volatile uint16_t result = 0;

//
//  Функция возвращает результат измерения, заодно обнуляя его
//
uint16_t measureResult(void) {
  cli();
  const uint16_t res = result;
  result = 0;
  sei();
  return res;
}

#ifdef  USE_TIMER_2
  //
  //  Если случилось 16-битное переполнение, значит истёк таймаут
  //  Ставим таймаут результатом и реинициализируем таймер 
  //  для следующегг измерения
  //
  ISR(TIMER2_OVF_vect) {
    ovfCounter += 256;
    if (!ovfCounter) {
      result = ENDLESS_INTERVAL;
      stopTimerCounter();
    }
  }
  
  //
  //  Прилетело прерывание
  //  Если на пинe PD2/PD3 высокий уровень - начинаем отсчёт
  //  Если на пине PD2/PD3 низкий уровень - заканчиваем отсчёт
  //
  //  Примечание: в этой функции количество тактов до включения таймера
  //  и до запоминания результата одинаковое, т.е. поправки не нужны.
  //  Теоретически одинаковость может пропасть при новой версии компилятора
  //  или при других опциях. Если есть сомнения, можно её убрать, а вместо ней
  //  использовать закомментированную (ниже) функцию с ассемблерным кодом.
  //  Там то уж никто не нагадит.
  //
  ISR(INT_VECT) {
    if (PIND & PIN_MASK) {
      TCCR2B = 1; // запускаем таймер
    } else {
      TCCR2B = 0; //  остановим таймер
      result = TCNT2;
      result += ovfCounter;
      stopTimerCounter();
    }
  }

#else //  USE_TIMER_2
  //
  //  Если случилось переполнение, значит истёк таймаут
  //  Ставим таймаут результатом и реинициализируем таймер 
  //  для следующегг измерения
  //
  ISR(TIMER1_OVF_vect) {
    result = ENDLESS_INTERVAL;
    stopTimerCounter();
  }
  
  //
  //  Прилетело прерывание
  //  Если на пинe PD2/PD3 высокий уровень - начинаем отсчёт
  //  Если на пине PD2/PD3 низкий уровень - заканчиваем отсчёт
  //
  //  Примечание: в этой функции количество тактов до включения таймера
  //  и до запоминания результата одинаковое, т.е. поправки не нужны.
  //  Теоретически одинаковость может пропасть при новой версии компилятора
  //  или при других опциях. Если есть сомнения, можно её убрать, а вместо ней
  //  использовать закомментированную (ниже) функцию с ассемблерным кодом.
  //  Там то уж никто не нагадит.
  //
  ISR(INT_VECT) {
    if (PIND & PIN_MASK) {
      TCCR1B = 1; // запускаем таймер
    } else {
      TCCR1B = 0; //  остановим таймер
      result = TCNT1;
      stopTimerCounter();
    }
  }
#endif  //  USE_TIMER_2
/*
ISR(INT_VECT) {
asm volatile(
   // if (PIND & bit(PDx))
      "sbis %[Prt],%[Mask]  \r\n" 
      "rjmp SignalEnds    \r\n"
  // {
      "ldi  r24, 1      \r\n" //  Единицу пихаем в TCCRB1
      "sts  %[TCCRB], r24 \r\n" //  т.е. запускаем таймер
      "rjmp AllDone     \r\n"  
  // } else {
    "SignalEnds: \r\n"
      "lds  r24, %[TCNTL] \r\n" // младший байт TCNT1 читаем раньше старшего
      "lds  r25, %[TCNTH] \r\n"
      "sts  %[res]+1, r25 \r\n" //  Значение TCNT1 пихаем 
      "sts  %[res], r24   \r\n" //  в переменнуюresult
      "sts  %[TCCRB], r1  \r\n" //  Пихаем 0 в TCCRB1 - останавливаем таймер
      "sts  %[TCNTH], r1  \r\n" // Пихаем 0 в TCNT1 на будущее 
      "sts  %[TCNTL], r1  \r\n" //  старший байт раньше младшего
  // }    
    "AllDone: \r\n"
    :
    [res] "=m" (result)
  : 
    [Prt] "I" (_SFR_IO_ADDR(PIND)), 
    [Mask] "M" (PIN_NUMBER),
    [TCCRB] "M" (_SFR_MEM_ADDR(TCCR1B)),
    [TCNTH] "M" (_SFR_MEM_ADDR(TCNT1H)),
    [TCNTL] "M" (_SFR_MEM_ADDR(TCNT1L))
  :
    "r24", "r25"
  );
}
*/

//
